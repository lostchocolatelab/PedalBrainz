
//  Welcome to Pedal Brainz
//
//  Routine Change
//  All potentiometers to zero (fully counter clockwise) for a second then rotate one potentiometer from zero for routine change.
//
//  Fadez Mode 1
//  A0 = Fade speed of LED
//  A1 = Delay when LED is fully on (It's Lit)
//  A2 = Delay when LED is fully off (It's Dark)
//
//  Fadez Mode 2
//  A0 = Amount of Random Time Added to A1, A2
//  A1 = Delay when LED is fully on (It's Lit)
//  A2 = Delay when LED is fully off (It's Dark)
//
//  Fadez Mode 3
//  A0 = Amount of Random Time Added to Fade Speed, A1, A2
//  A1 = Delay when LED is fully on (It's Lit)
//  A2 = Delay when LED is fully off (It's Dark)
//
//  Rainbow Mode 1
//  A0 = Rainbow Cycle Speed
//  A1 = Delay when LED is fully off (It's Dark)
//  A2 = Maximum Brightness
//
//  Rainbow Mode 2
//  A0 = Rainbow Cycle Speed
//  A1 = Delay when LED is fully off (It's Dark)
//  A2 = Randomized Maximum Brightness
//
//
//  Strange Attractors Modes 6-10
//  A0 = Cycle Speed
//  A1 = Amount of Randomness
//  A2 = Maximum Brightness
//
//  Mode 6: 1 Wave
//  Mode 7: 2 Wavez
//  Mode 8: 3 Wavez
//  Mode 9: 3 Wavez Alt
//  Mode 10: 3 Waves Unstable
//
//  -Lost Lab



#include <Adafruit_DotStar.h>
#include <FlashAsEEPROM_SAMD.h>

/* Set the on-board DotStar as "pixel". */
Adafruit_DotStar pixel = Adafruit_DotStar(1, INTERNAL_DS_DATA, INTERNAL_DS_CLK, DOTSTAR_BGR);

// Declare the potentiometer variables
int valueA0 = 135;
int valueA1 = 0;
int valueA2 = 0;

// Flash Memory EEPROM variables
uint16_t address = 0;
int number;
int startupMode = 1;

// Set a default variable for the red, blue, and green (RGB) value of the on-board Dot Star
// Pink! Potentiometer A0: 236 Potentiometer A1: 73 Potentiometer A2: 107

int redValue = 236;
int blueValue = 73;
int greenValue = 107;

int fadeSpeed = 13;
int fullDelay = 0;
int darkDelay = 0;

int delayRandom = random(0, 1000);
int randomAmount = 0;
int delayValue = 0;

unsigned long myTime;
int LEDBrightness;


// Routines Declarations
// Some Colors
uint32_t Sketch2Blue = 0x0000FF;
uint32_t Sketch2Red = 0xFF0000;
uint32_t Sketch2Green = 0x00FF00;
uint32_t Sketch2Yellow = 0xFFFF00;
uint32_t Sketch2Pink = 0xFF69B4;
uint32_t Sketch2Orange = 0xFF8000;
uint32_t CurrentColor = Sketch2Pink;

int FlashDelay;
int Brightnesslevel;
int rainbowBright = 255;

boolean waitingFlag = false;
boolean WaitForRoutineChange = true;
boolean ValueZeroReached = false;
boolean ValueHighReached = false;
int ValueHighlight = 0;
long ValueHighlightTime;
long ValueZeroTime, ValueHighTime;
int ValueZeroAdjustment = 20;
int RoutineFlashDelay = 100;
boolean initial = true;

long WaitTime = 200;

int Mode = 0;

//Rainbow Mode Declarations
unsigned short pixelnumber = 0;

// Strange Attractor Declarations

//Coordinates for the lorenz function
float x = 0;
float y = 0;
float z = 0;
float scaledX = 0;
float scaledY = 0;
float scaledZ = 0;
float effectiveR = 0;
float effectiveG = 0;
float effectiveB = 0;

//Constants for the lorenz function, KEEP UNCHANGED
float a = 10.0;
float b = 28.0;
float c = 8.0 / 3.0;

//Variables for lorenz function
float dx = 0;
float dy = 0;
float dz = 0;

//Variables for timing
float dt = 0.01;  //Time between interval (seconds) default: 10ms (0.01s) you can change it but the code become unstable
unsigned long nextLorenzUpdate = 0;
int printDelay = 10; //Time between each serial print (default: 50ms)


float scalings[2][3] {
                      {0,0,0},  //minX, minY, minZ
                      {0,0,0}   //maxX, maxY, maxZ 
                     };

int brightness = 0;
int fadeAmount = 1;  //Change it to adjust the fading between each step (fading speed)
int maxBrightness = 255;
int delayAmount = 0;

/**

  Rainbow Mode - Arrays of numbers

*/

const uint8_t lights[360] = {
  0,   0,   0,   0,   0,   1,   1,   2,
  2,   3,   4,   5,   6,   7,   8,   9,
  11,  12,  13,  15,  17,  18,  20,  22,
  24,  26,  28,  30,  32,  35,  37,  39,
  42,  44,  47,  49,  52,  55,  58,  60,
  63,  66,  69,  72,  75,  78,  81,  85,
  88,  91,  94,  97, 101, 104, 107, 111,
  114, 117, 121, 124, 127, 131, 134, 137,
  141, 144, 147, 150, 154, 157, 160, 163,
  167, 170, 173, 176, 179, 182, 185, 188,
  191, 194, 197, 200, 202, 205, 208, 210,
  213, 215, 217, 220, 222, 224, 226, 229,
  231, 232, 234, 236, 238, 239, 241, 242,
  244, 245, 246, 248, 249, 250, 251, 251,
  252, 253, 253, 254, 254, 255, 255, 255,
  255, 255, 255, 255, 254, 254, 253, 253,
  252, 251, 251, 250, 249, 248, 246, 245,
  244, 242, 241, 239, 238, 236, 234, 232,
  231, 229, 226, 224, 222, 220, 217, 215,
  213, 210, 208, 205, 202, 200, 197, 194,
  191, 188, 185, 182, 179, 176, 173, 170,
  167, 163, 160, 157, 154, 150, 147, 144,
  141, 137, 134, 131, 127, 124, 121, 117,
  114, 111, 107, 104, 101,  97,  94,  91,
  88,  85,  81,  78,  75,  72,  69,  66,
  63,  60,  58,  55,  52,  49,  47,  44,
  42,  39,  37,  35,  32,  30,  28,  26,
  24,  22,  20,  18,  17,  15,  13,  12,
  11,   9,   8,   7,   6,   5,   4,   3,
  2,   2,   1,   1,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0
};

const uint8_t HSVlights[61] =
{ 0, 4, 8, 13, 17, 21, 25, 30, 34, 38, 42, 47, 51, 55, 59, 64, 68, 72, 76,
  81, 85, 89, 93, 98, 102, 106, 110, 115, 119, 123, 127, 132, 136, 140, 144,
  149, 153, 157, 161, 166, 170, 174, 178, 183, 187, 191, 195, 200, 204, 208,
  212, 217, 221, 225, 229, 234, 238, 242, 246, 251, 255
};

const uint8_t HSVlightsFwdRev[120] =
{ 0, 4, 8, 13, 17, 21, 25, 30, 34, 38, 42, 47, 51, 55, 59, 64, 68, 72, 76,
  81, 85, 89, 93, 98, 102, 106, 110, 115, 119, 123, 127, 132, 136, 140, 144,
  149, 153, 157, 161, 166, 170, 174, 178, 183, 187, 191, 195, 200, 204, 208,
  212, 217, 221, 225, 229, 234, 238, 242, 246, 251, 255, 251, 246, 242, 238,
  234, 229, 225, 221, 217, 212, 208, 204, 200, 195, 191, 187, 183, 178, 174,
  170, 166, 161, 157, 153, 149, 144, 140, 136, 132, 127, 123, 119, 115, 110,
  106, 102, 98, 93, 89, 85, 81, 76, 72, 68, 64, 59, 55, 51, 47, 42, 38, 34,
  30, 25, 21, 17, 13, 8, 4
};

const uint8_t HSVpower[121] =
{ 0, 2, 4, 6, 8, 11, 13, 15, 17, 19, 21, 23, 25, 28, 30, 32, 34, 36, 38, 40,
  42, 45, 47, 49, 51, 53, 55, 57, 59, 62, 64, 66, 68, 70, 72, 74, 76, 79, 81,
  83, 85, 87, 89, 91, 93, 96, 98, 100, 102, 104, 106, 108, 110, 113, 115, 117,
  119, 121, 123, 125, 127, 130, 132, 134, 136, 138, 140, 142, 144, 147, 149,
  151, 153, 155, 157, 159, 161, 164, 166, 168, 170, 172, 174, 176, 178, 181,
  183, 185, 187, 189, 191, 193, 195, 198, 200, 202, 204, 206, 208, 210, 212,
  215, 217, 219, 221, 223, 225, 227, 229, 232, 234, 236, 238, 240, 242, 244,
  246, 249, 251, 253, 255
};

/**

  Setup

*/

void setup() {
  Serial.begin(115200); 
  /* Start the DotStar LED */
  pixel.begin();
  pixel.setBrightness(255);
  pixel.setPixelColor(0, redValue, blueValue, greenValue);
  pixel.show();

}

/**

  Loop

*/


void loop() {

    // This is the function that handles startup and Mode switching
    Routines();

    // plotCycle writes values to the Serial Monitor for plotting/
    // This is sprinkled throughout the code in-order to update the values on the Serial Plotter
    plotCycle(); 

    // Some memory Print
    //Serial.print(F("freeMemory: "));
    //Serial.println((int)freeMemory);

}



void Routines()
{
  
    // Pring the Mode value currently initialized
    //Serial.println("Mode : "+ String(Mode));
    
    plotCycle(); 

  //This is the initial startup mode (Mode = 0)
  //Things are about to start kicking in...

  if (Mode == 0)
  {

    // Fade in from the beginning of the Rainbow cycle (starts with the color Red)
    // This "for loop" adds to "x" which is set to zero (0) until it reaches 255 (Max Brightness)
    for (int x = 0; x < 255; x++)
    {
      //Setting a default rate for the rainbow cycling during startup
      valueA0 = 2;
      valueA2 = 255;

      // Increase the value of the Red value (x) causing a fade in;
      // "pixel" = what we defined the "Adafruit_DotStar" at the start of this Sketch
      // setPixelColor - how to set the pixel color
      // pixelnumber - defined as zero (0) above
      // 0, 0, 0 - These are the R(ed), G(reen), B(lue), values of the pixel from 0-255
      // x is currently being used as a variable to increment/ decrement the fade
      
      pixel.setPixelColor(pixelnumber, x, 0, 0);

      // A delay amount between each increase in colorvalue
      // Currently using the default for A0 set above
      delay(valueA0 / 2);
      pixel.show();
    }

    //Run the Rainbow cycle
    for (int k = 0; k < 360; k++)
    {

      // Rainbow Mode was adapted from an example online (See attribution at the end)
      // Several types of rainbow cycling were included and kept
      // Uncomment one of the mode (or modes?) to use for Rainbow Mode

      // trueHSV(0, k);
      powerHSV(0, k);
      // sineLED(0, k);
      pixel.show();

      // Set the rate of the rainbow cycling during initialization
      valueA0 = 2;
      delay(valueA0);

      // Set the maximum brightness of the pixel during initialization
      valueA2 = 255;
      pixel.setBrightness(valueA2);

    }


    // Fade out from the end of the Rainbow (lol) cycle (ends with the color Red)
    for (int x = 255; x >= 0; x--)
    {
      // Setting a default rate for the rainbow cycling during startup
      valueA0 = 2;
      valueA2 = 255;

      // Reduces the value of the Red (x) value causing a fade out
      pixel.setPixelColor(pixelnumber, x, 0, 0);

      // A delay amount between each increase in colorvalue
      // Currently using the default for A0 set above
      delay(valueA0 / 2);
      pixel.show();
    }

    // Add a delay (ms) at the end of the rainbow cycle using potantiometer A2 while the LED is dark
    valueA1 = 0;
    //delay(valueA1);

    //Serial.println("Rate of Rainbow cycling: " + String(valueA0)  + " ||| Delay between Rainbow cycles (ms): " + String(valueA1) + " ||| Maximum Brightness value: " + String(valueA2));
    //delay(400);

/**

 Read & Set Startup Mode

*/
    
    // Read the values of Startup Mode
    readStartupMode();
    Serial.println("I Read startupMode - "+ String(startupMode));
    
    // Set the Mode to the value of startupMode
    Mode = startupMode;
    Serial.println("Mode set to startupMode - "+ String(Mode));

    // If the Mode is 1 or less, set the Mode to 1
    // If there's nothing saved start Modes from the beginning
    if (1 >= Mode)
    {
      Mode = 1;
      Serial.println("Mode was equal to or less than - "+ String(Mode));
    }

    // If the Mode is 2 or more, set the Mode to startupMode
    // If a mode has been saved, set the saved startupMode as the Mode
    else if (2 <= Mode)
    {
      Mode = startupMode;
      Serial.println("Mode was greater than one - "+ String(Mode));
    }
    
  }

 /**

 Fadez

*/ 

  //Fadez 01
  if (Mode == 1)
  {
    if (!waitingFlag)
    {
      for (int i = 0; i < 3; i++)
      {
        pixel.setBrightness(100);
        pixel.setPixelColor(0, Sketch2Pink); // Red
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
      }
      /**if (initial)
        {
        pixel.setBrightness(255);
        pixel.setPixelColor(0, Sketch2Yellow); // Yellow
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
        initial = false;
        }
        else
        {*/
      pixel.setBrightness(100);
      pixel.setPixelColor(0, Sketch2Yellow); // Yellow
      pixel.show();
      delay(RoutineFlashDelay);
      pixel.setPixelColor(0, 0x000000); // Blank
      pixel.show();
      delay(RoutineFlashDelay);
      //}

      //Do the last thing and WaitForRoutineChange
      
      pixel.setBrightness(255);
      pixel.setPixelColor(0, 115, 0, 130);
      //52,24,130
      pixel.show();

      waitingFlag = true;
      WaitForRoutineChange = true;
      Serial.println(" WaitForRoutineChange = True");
    }
    else
    {
      if (WaitForRoutineChange)
      {

        //Call the main routine and loop the thing
        Fadez_01 ();
        
        if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment))
        {
          Serial.println(" WaitForRoutineChange = False");
          WaitForRoutineChange = false;
          delay(200);
        }
      }

      if (((analogRead(A0) > ValueZeroAdjustment) or (analogRead(A1) > ValueZeroAdjustment) or (analogRead(A2) > ValueZeroAdjustment)) && (!WaitForRoutineChange))
      {
        Mode = 2;
        waitingFlag = false;
        WaitForRoutineChange = false;
        Serial.println(" WaitForRoutineChange = False & WaitingFlag = False");
      }
    }
  }

  //Fadez 02
  if (Mode == 2)
  {
    if (!waitingFlag)
    {
      for (int i = 0; i < 2; i++)
      {
        pixel.setBrightness(100);
        pixel.setPixelColor(0, Sketch2Blue); // Red
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
      }

      pixel.setBrightness(100);
      pixel.setPixelColor(0, Sketch2Pink); // Pink
      pixel.show();
      delay(RoutineFlashDelay);
      pixel.setPixelColor(0, 0x000000); // Blank
      pixel.show();
      delay(RoutineFlashDelay);

      //Do the last thing and WaitForRoutineChange

      pixel.setBrightness(255);
      pixel.setPixelColor(0, 36, 0, 255);
      //0,0,255
      pixel.show();

      waitingFlag = true;
      WaitForRoutineChange = true;
      Serial.println(" WaitForRoutineChange = True");
    }
    else
    {
      if (WaitForRoutineChange)
      {
     
        //Call the main routine and loop the thing
        Fadez_01 ();

        if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment))
        {
          WaitForRoutineChange = false;
          Serial.println(" WaitForRoutineChange = False");
          delay(200);
        }
      }

      if (((analogRead(A0) > ValueZeroAdjustment) or (analogRead(A1) > ValueZeroAdjustment) or (analogRead(A2) > ValueZeroAdjustment)) && (!WaitForRoutineChange))
      {
        Mode = 3;
        waitingFlag = false;
        WaitForRoutineChange = false;
        Serial.println(" WaitForRoutineChange = False & WaitingFlag = False");
      }
    }
  }

  //Fadez 03
  if (Mode == 3)
  {
    if (!waitingFlag)
    {
      for (int i = 0; i < 2; i++)
      {
        pixel.setBrightness(100);
        pixel.setPixelColor(0, Sketch2Green); // Red
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
      }

      pixel.setBrightness(100);
      pixel.setPixelColor(0, Sketch2Orange); // Orange
      pixel.show();
      delay(RoutineFlashDelay);
      pixel.setPixelColor(0, 0x000000); // Blank
      pixel.show();
      delay(RoutineFlashDelay);

      //Do the last thing and WaitForRoutineChange
      
      pixel.setBrightness(255);
      pixel.setPixelColor(0, 0, 255, 60);
      //31,255,60
      pixel.show();

      waitingFlag = true;
      WaitForRoutineChange = true;
      Serial.println(" WaitForRoutineChange = True");
    }
    else
    {
      if (WaitForRoutineChange)
      {

        //Call the main routine and loop the thing
        Fadez_01 ();

        if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment))
        {
          WaitForRoutineChange = false;
          Serial.println(" WaitForRoutineChange = False");
          delay(200);
        }
      }

      if (((analogRead(A0) > ValueZeroAdjustment) or (analogRead(A1) > ValueZeroAdjustment) or (analogRead(A2) > ValueZeroAdjustment)) && (!WaitForRoutineChange))
      {
        Mode = 4;
        waitingFlag = false;
        WaitForRoutineChange = false;
        Serial.println(" WaitForRoutineChange = False & WaitingFlag = False");
      }
    }
  }

  //Rainbow 01
  if (Mode == 4)
  {
    if (!waitingFlag)
    {
      for (int i = 0; i < 2; i++)
      {
        pixel.setBrightness(100);
        pixel.setPixelColor(0, Sketch2Red); // Red
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
      }

      pixel.setBrightness(100);
      pixel.setPixelColor(0, Sketch2Orange); // Orange
      pixel.show();
      delay(RoutineFlashDelay);
      pixel.setPixelColor(0, 0x000000); // Blank
      pixel.show();
      delay(RoutineFlashDelay);

      //Do the last thing and WaitForRoutineChange

      pixel.setBrightness(100);
      pixel.setPixelColor(0, 36, 200, 10);
      pixel.show();
      
      waitingFlag = true;
      WaitForRoutineChange = true;
      Serial.println(" WaitForRoutineChange = True");
    }
    else
    {
      if (WaitForRoutineChange)
      {
        //Call the main routine and loop the thing
        RainbowMode ();

        if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment))
        {
          WaitForRoutineChange = false;
          Serial.println(" WaitForRoutineChange = False");
          delay(200);
        }
      }

      if (((analogRead(A0) > ValueZeroAdjustment) or (analogRead(A1) > ValueZeroAdjustment) or (analogRead(A2) > ValueZeroAdjustment)) && (!WaitForRoutineChange))
      {
        Mode = 5;
        waitingFlag = false;
        WaitForRoutineChange = false;
        Serial.println(" WaitForRoutineChange = False & WaitingFlag = False");
      }
    }
  }

  //Rainbow 02
  if (Mode == 5)
  {
    if (!waitingFlag)
    {
      for (int i = 0; i < 2; i++)
      {
        pixel.setBrightness(100);
        pixel.setPixelColor(0, Sketch2Pink); // Pink
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
      }

      pixel.setBrightness(100);
      pixel.setPixelColor(0, Sketch2Orange); // Orange
      pixel.show();
      delay(RoutineFlashDelay);
      pixel.setPixelColor(0, 0x000000); // Blank
      pixel.show();
      delay(RoutineFlashDelay);

      //Do the last thing and WaitForRoutineChange

      pixel.setBrightness(100);
      pixel.setPixelColor(0, 36, 200, 10);
      pixel.show();
      
      waitingFlag = true;
      WaitForRoutineChange = true;
      Serial.println(" WaitForRoutineChange = True");
    }
    else
    {
      if (WaitForRoutineChange)
      {
        //Call the main routine and loop the thing
        RainbowMode ();

        if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment))
        {
          WaitForRoutineChange = false;
          Serial.println(" WaitForRoutineChange = False");
          delay(200);
        }
      }

      if (((analogRead(A0) > ValueZeroAdjustment) or (analogRead(A1) > ValueZeroAdjustment) or (analogRead(A2) > ValueZeroAdjustment)) && (!WaitForRoutineChange))
      {
        Mode = 6;
        waitingFlag = false;
        WaitForRoutineChange = false;
        Serial.println(" WaitForRoutineChange = False & WaitingFlag = False");
      }
    }
  }

// Strange Attractor 1
  if (Mode == 6)
  {
    if (!waitingFlag)
    {
      for (int i = 0; i < 2; i++)
      {
        pixel.setBrightness(100);
        pixel.setPixelColor(0, Sketch2Pink); // Pink
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
      }

      pixel.setBrightness(100);
      pixel.setPixelColor(0, Sketch2Orange); // Orange
      pixel.show();
      delay(RoutineFlashDelay);
      pixel.setPixelColor(0, 0x000000); // Blank
      pixel.show();
      delay(RoutineFlashDelay);

      //Do the last thing and WaitForRoutineChange

      pixel.setBrightness(100);
      pixel.setPixelColor(0, 36, 200, 10);
      pixel.show();

      x = 0.01;
      y = 0.3;
      z = 0.7;
      
      waitingFlag = true;
      WaitForRoutineChange = true;
      Serial.println(" WaitForRoutineChange = True");
    }
    else
    {
      if (WaitForRoutineChange)
      {
        //Call the main routine and loop the thing
        strangeAttractor();

        if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment))
        {
          WaitForRoutineChange = false;
          Serial.println(" WaitForRoutineChange = False");
          delay(200);
        }
      }

      if (((analogRead(A0) > ValueZeroAdjustment) or (analogRead(A1) > ValueZeroAdjustment) or (analogRead(A2) > ValueZeroAdjustment)) && (!WaitForRoutineChange))
      {
        Mode = 7;
        waitingFlag = false;
        WaitForRoutineChange = false;
        Serial.println(" WaitForRoutineChange = False & WaitingFlag = False");
      }
    }
  }

// Strange Attractor 2
  if (Mode == 7)
  {
    if (!waitingFlag)
    {
      for (int i = 0; i < 2; i++)
      {
        pixel.setBrightness(100);
        pixel.setPixelColor(0, Sketch2Pink); // Pink
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
      }

      pixel.setBrightness(100);
      pixel.setPixelColor(0, Sketch2Orange); // Orange
      pixel.show();
      delay(RoutineFlashDelay);
      pixel.setPixelColor(0, 0x000000); // Blank
      pixel.show();
      delay(RoutineFlashDelay);

      //Do the last thing and WaitForRoutineChange

      pixel.setBrightness(100);
      pixel.setPixelColor(0, 36, 200, 10);
      pixel.show();

      x = 0.01;
      y = 0.3;
      z = 0.7;
      
      waitingFlag = true;
      WaitForRoutineChange = true;
      Serial.println(" WaitForRoutineChange = True");
    }
    else
    {
      if (WaitForRoutineChange)
      {
        //Call the main routine and loop the thing
        strangeAttractor();

        if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment))
        {
          WaitForRoutineChange = false;
          Serial.println(" WaitForRoutineChange = False");
          delay(200);
        }
      }

      if (((analogRead(A0) > ValueZeroAdjustment) or (analogRead(A1) > ValueZeroAdjustment) or (analogRead(A2) > ValueZeroAdjustment)) && (!WaitForRoutineChange))
      {
        Mode = 8;
        waitingFlag = false;
        WaitForRoutineChange = false;
        Serial.println(" WaitForRoutineChange = False & WaitingFlag = False");
      }
    }
  }

 // Strange Attractor 3
  if (Mode == 8)
  {
    if (!waitingFlag)
    {
      for (int i = 0; i < 2; i++)
      {
        pixel.setBrightness(100);
        pixel.setPixelColor(0, Sketch2Pink); // Pink
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
      }

      pixel.setBrightness(100);
      pixel.setPixelColor(0, Sketch2Orange); // Orange
      pixel.show();
      delay(RoutineFlashDelay);
      pixel.setPixelColor(0, 0x000000); // Blank
      pixel.show();
      delay(RoutineFlashDelay);

      //Do the last thing and WaitForRoutineChange

      pixel.setBrightness(100);
      pixel.setPixelColor(0, 36, 200, 10);
      pixel.show();

      x = 0.01;
      y = 0.3;
      z = 0.7;
      
      waitingFlag = true;
      WaitForRoutineChange = true;
      Serial.println(" WaitForRoutineChange = True");
    }
    else
    {
      if (WaitForRoutineChange)
      {
        //Call the main routine and loop the thing
        strangeAttractor();

        if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment))
        {
          WaitForRoutineChange = false;
          Serial.println(" WaitForRoutineChange = False");
          delay(200);
        }
      }

      if (((analogRead(A0) > ValueZeroAdjustment) or (analogRead(A1) > ValueZeroAdjustment) or (analogRead(A2) > ValueZeroAdjustment)) && (!WaitForRoutineChange))
      {
        Mode = 9;
        waitingFlag = false;
        WaitForRoutineChange = false;
        Serial.println(" WaitForRoutineChange = False & WaitingFlag = False");
      }
    }
  }   
 // Strange Attractor 4
  if (Mode == 9)
  {
    if (!waitingFlag)
    {
      for (int i = 0; i < 2; i++)
      {
        pixel.setBrightness(100);
        pixel.setPixelColor(0, Sketch2Pink); // Pink
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
      }

      pixel.setBrightness(100);
      pixel.setPixelColor(0, Sketch2Orange); // Orange
      pixel.show();
      delay(RoutineFlashDelay);
      pixel.setPixelColor(0, 0x000000); // Blank
      pixel.show();
      delay(RoutineFlashDelay);

      //Do the last thing and WaitForRoutineChange

      pixel.setBrightness(100);
      pixel.setPixelColor(0, 36, 200, 10);
      pixel.show();

      x = 0.01;
      y = 0.3;
      z = 0.7;
      
      waitingFlag = true;
      WaitForRoutineChange = true;
      Serial.println(" WaitForRoutineChange = True");
    }
    else
    {
      if (WaitForRoutineChange)
      {
        //Call the main routine and loop the thing
        strangeAttractor();

        if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment))
        {
          WaitForRoutineChange = false;
          Serial.println(" WaitForRoutineChange = False");
          delay(200);
        }
      }

      if (((analogRead(A0) > ValueZeroAdjustment) or (analogRead(A1) > ValueZeroAdjustment) or (analogRead(A2) > ValueZeroAdjustment)) && (!WaitForRoutineChange))
      {
        Mode = 10;
        waitingFlag = false;
        WaitForRoutineChange = false;
        Serial.println(" WaitForRoutineChange = False & WaitingFlag = False");
      }
    }
  }
  
 // Strange Attractor 5
  if (Mode == 10)
  {
    if (!waitingFlag)
    {
      for (int i = 0; i < 2; i++)
      {
        pixel.setBrightness(100);
        pixel.setPixelColor(0, Sketch2Pink); // Pink
        pixel.show();
        delay(RoutineFlashDelay);
        pixel.setPixelColor(0, 0x000000); // Blank
        pixel.show();
        delay(RoutineFlashDelay);
      }

      pixel.setBrightness(100);
      pixel.setPixelColor(0, Sketch2Orange); // Orange
      pixel.show();
      delay(RoutineFlashDelay);
      pixel.setPixelColor(0, 0x000000); // Blank
      pixel.show();
      delay(RoutineFlashDelay);

      //Do the last thing and WaitForRoutineChange

      pixel.setBrightness(100);
      pixel.setPixelColor(0, 36, 200, 10);
      pixel.show();

      x = 0.01;
      y = 0.3;
      z = 0.7;
      
      waitingFlag = true;
      WaitForRoutineChange = true;
      Serial.println(" WaitForRoutineChange = True");
    }
    else
    {
      if (WaitForRoutineChange)
      {
        //Call the main routine and loop the thing
        strangeAttractor();

        if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment))
        {
          WaitForRoutineChange = false;
          Serial.println(" WaitForRoutineChange = False");
          delay(200);
        }
      }

      if (((analogRead(A0) > ValueZeroAdjustment) or (analogRead(A1) > ValueZeroAdjustment) or (analogRead(A2) > ValueZeroAdjustment)) && (!WaitForRoutineChange))
      {
        Mode = 1;
        waitingFlag = false;
        WaitForRoutineChange = false;
        Serial.println(" WaitForRoutineChange = False & WaitingFlag = False");
      }
    }
  }    


}



void Fadez_01 () {

    plotCycle();  

if (Mode == 1)
{
      redValue = 115;
      greenValue = 0;
      blueValue = 130;
}
if (Mode == 2) // pixel.setPixelColor(0, 36, 0, 255);
{
      redValue = 36;
      greenValue = 0;
      blueValue = 255;
}
if (Mode == 3) //pixel.setPixelColor(0, 0, 255, 60);
{
      redValue = 0;
      greenValue = 255;
      blueValue = 60;
}
else;

      
  int x = 1;

  //This fades the brightness in and out using maths
  for (int i = 0; i > -1; i = i + x) {
    
    pixel.setBrightness(i);
    pixel.show();

    plotCycle(); 

             
      //Experiment in-progress
      //pixel.setPixelColor(0, redValue-i/2, greenValue, blueValue-i);
      //52,24,130

    //If the fade has reached it's peak keep the LED lit and then fade out

    if (i == 155) {

      //Mode changes to the delay time when LED is full color value for potentiometer A1
      //Use the value of A1 to keep the LED fully lit by the amount of A1 (delay) and then start fading out
      
      delayA1(fullDelay);
      //Serial.println("Delay when LED fully lit (ms): " + String(fullDelay));
      
      plotCycle(); 

      x = -1;  // switch direction at peak
      
      //Experiment in-progress
      //pixel.setPixelColor(0, redValue+i, greenValue, blueValue-i);
    }

    //Mode changes to the delay time of the fade speed for potentiometer A0
    //Use the value of A0 to control the rate of fade in/out using a delay
    
    delayA0(fadeSpeed);
    //Serial.println("Rate of Fade in/ Fade out: " + String(fadeSpeed));

    plotCycle(); 
    
  }
  //Serial.println("Rate of Fade in/ Fade out: " + String(valueA0));

  //Mode changes to the delay time of the fade speed for potentiometer A2
  //Use the value of A2 to keep the LED fully dark (delay) between fade in/fade out
  
  delayA2(darkDelay);
  //Serial.println("Delay when LED fully dark (ms): " + String(darkDelay));

    plotCycle();  
    
    randomAmount = random(0, delayValue);
  //Serial.println("Rate of Fade in/ Fade out: " + String(fadeSpeed) + " ||| Delay when LED fully lit (ms): " + String(fullDelay) + " ||| Delay when LED fully dark (ms): " + String(darkDelay));
}


/**

  A0 Delay - Fade Speed

*/


void delayA0(int count)
{

  int delayCountA0 = fadeSpeed;

    plotCycle(); 

  for (int count = 0; count <= delayCountA0; count++) {
    
    delayCountA0 = fadeSpeed;
    
    plotCycle(); 

    if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment)) {
      count = 0;
      break;
      Serial.println("I Broke");
    }
    
    if (Mode == 1) {
      //Potentiometer Top Right | A0 - Map the value of the potentiometer to the variable valueA0
      fadeSpeed = map(analogRead(A0), 0, 1024, 136, 0);
      //Serial.println("Mode 1 fadeSpeeed: " + String(fadeSpeed));
    }
    else if (Mode == 2) {
      //Potentiometer Top Right | A0 - Map the value of the potentiometer to the variable valueA1
      //delayValue = map(analogRead(A0), 0, 1024, 0, 5000);
      //fadeSpeed = random(0, delayValue);
      
      fadeSpeed = 7;
      //Serial.println("Delay Random (ms): " + String(delayRandom));
      //Serial.println("Mode 2 fadeSpeeed: " + String(fadeSpeed));
    }
    else if (Mode == 3) {
      //Potentiometer Top Right | A0 - Map the value of the potentiometer to the variable valueA1
      
      valueA0 = map(analogRead(A0), 0, 1024, 60, 20);
      delayValue = map(analogRead(A0), 0, 1024, 0, 40);
      //randomAmount = random(0, delayValue);
      
      fadeSpeed = valueA0 + randomAmount;
      //Serial.println("Mode 3 fadeSpeed Random: " + String(randomAmount));
      //Serial.println("Mode 3 fadeSpeeed: " + String(fadeSpeed));
    }
     else if (Mode == 4) {
      //Potentiometer Top Right | A0 - Map the value of the potentiometer to the variable valueA0
      fadeSpeed = map(analogRead(A0), 0, 1024, 20, -1);
      //Serial.println("Mode 4 fadeSpeeed: " + String(fadeSpeed));
    }
     else if (Mode == 5) {
      //Potentiometer Top Right | A0 - Map the value of the potentiometer to the variable valueA0
      fadeSpeed = map(analogRead(A0), 0, 1024, 20, -1);
      //Serial.println("Mode 4 fadeSpeeed: " + String(fadeSpeed));
    }
    else {
      fadeSpeed = 7;
      //Serial.println("Else fadeSpeeed: " + String(fadeSpeed));
    }

    //Make this number smaller to fade faster
    delay(.5);
    controlsMax();
    //Serial.println("Count if Waiting = False: " + String(count));
  }
}

/**

  A1 Delay - Full Delay

*/


void delayA1(int count)
{

  int delayCountA1 = fullDelay;

  for (int count = 0; count <= delayCountA1; count++) {
    
    delayCountA1 = fullDelay;
    
    plotCycle(); 

    if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment)) {
      count = 0;
      break;
      Serial.println("I Broke");
    }
    if (Mode == 1) {
      //Potentiometer Top Left | A1 - Map the value of the potentiometer to the variable valueA1
      fullDelay = map(analogRead(A1), 0, 1024, 0, 5000);
      //Serial.println("Mode 1 fullDelay: " + String(fullDelay));
    }
    else if (Mode == 2) {
      //Potentiometer Top Right | A0 - Map the value of the potentiometer to the variable valueA0
      //Potentiometer Top Left | A1 - Map the value of the potentiometer to the variable valueA1
      
      valueA1 = map(analogRead(A1), 0, 1024, 0, 5000);
      delayValue = map(analogRead(A0), 0, 1024, 0, 5000);
      randomAmount = random(0, delayValue);
      fullDelay = valueA1 + randomAmount;
      //Serial.println("Mode 2 fullDelay Random: " + String(randomAmount));
      //Serial.println("Mode 2 fullDelay: " + String(fullDelay));
    }
    else if (Mode == 3) {
      //Potentiometer Top Right | A0 - Map the value of the potentiometer to the variable valueA0
      //Potentiometer Top Left | A1 - Map the value of the potentiometer to the variable valueA1
      
      valueA1 = map(analogRead(A1), 0, 1024, 0, 5000);
      delayValue = map(analogRead(A0), 0, 1024, 0, 5000);
      randomAmount = random(0, delayValue);
      fullDelay = valueA1 + randomAmount;
      //Serial.println("Mode 3 fullDelay Random: " + String(randomAmount));
      //Serial.println("Mode 3 fullDelay: " + String(fullDelay));
    }
    else if (Mode == 4) {
      //Potentiometer Top Left | A1 - Map the value of the potentiometer to the variable valueA1
      valueA1 = map(analogRead(A1), 0, 1024, 0, 5000);
      fullDelay =  valueA1;
      //Serial.println("Mode 4 darkDelay: " + String(fullDelay));
    }
    else if (Mode == 5) {
      //Potentiometer Top Left | A1 - Map the value of the potentiometer to the variable valueA1
      valueA1 = map(analogRead(A1), 0, 1024, 0, 5000);
      fullDelay =  valueA1;
      //Serial.println("Mode 4 darkDelay: " + String(fullDelay));
    }   else {
      fullDelay = 100;
      //Serial.println("Else fullDelay: " + String(fullDelay));
    }

    delay(1);
    controlsMax();
    //Serial.println("Count if Waiting = False: " + String(count));
  }
}

/**

  A2 Delay - Dark Delay

*/


void delayA2(int count)
{

  int delayCountA2 = darkDelay;

  for (int count = 0; count <= delayCountA2; count++) {
    
    delayCountA2 = darkDelay;
    
    plotCycle();
    
    if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment)) {
      count = 0;
      break;
      Serial.println("I Broke");
    }
  if (Mode == 1) {
    //Potentiometer Bottom Right | A2 - Map the value of the potentiometer to the variable valueA2
    
    darkDelay = map(analogRead(A2), 0, 1024, 0, 5000);
    //Serial.println("Mode 1 darkDelay: " + String(darkDelay));
  }
  else if (Mode == 2) {
    //Potentiometer Top Right | A0 - Map the value of the potentiometer to the variable valueA0
    //Potentiometer Top Left | A2 - Map the value of the potentiometer to the variable valueA1
    
    valueA2 = map(analogRead(A2), 0, 1024, 0, 5000);
    delayValue = map(analogRead(A0), 0, 1024, 0, 5000);
    //randomAmount = random(0, delayValue);
    
    darkDelay = valueA2 + randomAmount;
    //Serial.println("Mode 2 darkDelay Random: " + String(randomAmount));
    //Serial.println("Mode 2 darkDelay: " + String(darkDelay));
  }
  else if (Mode == 3) {
    //Potentiometer Top Right | A0 - Map the value of the potentiometer to the variable valueA0
    //Potentiometer Top Left | A2 - Map the value of the potentiometer to the variable valueA1
    
    valueA2 = map(analogRead(A2), 0, 1024, 0, 5000);
    delayValue = map(analogRead(A0), 0, 1024, 0, 5000);
    //randomAmount = random(0, delayValue);
    
    darkDelay = valueA2 + randomAmount;
    //Serial.println("Mode 3 darkDelay Random: " + String(randomAmount));
    //Serial.println("Mode 3 darkDelay: " + String(darkDelay));
  }
  else {
    darkDelay = 100;
    //Serial.println("Else darkDelay: " + String(darkDelay));
  }

    delay(1);
    controlsMax();
    //Serial.println("Count if Waiting = False: " + String(count));
  }
}


/**

  Rainbow mode Setups

*/

void setRGBpoint(int pixelnumber, uint8_t redValue, uint8_t greenValue, uint8_t blueValue)
{
  pixel.setPixelColor(pixelnumber, redValue, 0, 0);
  pixel.setPixelColor(pixelnumber, 0, greenValue, 0);
  pixel.setPixelColor(pixelnumber, 0, 0, blueValue);

  //Serial.println(redValue);
  //Serial.println(greenValue);
  //Serial.println(blueValue);
}

// the real HSV rainbow
void trueHSV(int pixelnumber, int angle)
{
  byte red, green, blue;

  if (angle < 60) {
    redValue = 255;
    greenValue = HSVlights[angle];
    blueValue = 0;
  } else if (angle < 120) {
    redValue = HSVlights[120 - angle];
    greenValue = 255;
    blueValue = 0;
  } else if (angle < 180) {
    redValue = 0, greenValue = 255;
    blueValue = HSVlights[angle - 120];
  } else if (angle < 240) {
    redValue = 0, greenValue = HSVlights[240 - angle];
    blueValue = 255;
  } else if (angle < 300) {
    redValue = HSVlights[angle - 240], greenValue = 0;
    blueValue = 255;
  } else
  {
    redValue = 255, greenValue = 0;
    blueValue = HSVlights[360 - angle];
  }
  setRGBpoint(pixelnumber, redValue, greenValue, blueValue);
  pixel.setPixelColor(pixelnumber, redValue, greenValue, blueValue);

}

// the 'power-conscious' HSV rainbow
void powerHSV(int pixelnumber, int angle)
{
  byte redValue, greenValue, blueValue;
  if (angle < 120) {
    redValue = HSVpower[120 - angle];
    greenValue = HSVpower[angle];
    blueValue = 0;
  } else if (angle < 240) {
    redValue = 0;
    greenValue = HSVpower[240 - angle];
    blueValue = HSVpower[angle - 120];
  } else
  {
    redValue = HSVpower[angle - 240];
    greenValue = 0;
    blueValue = HSVpower[360 - angle];
  }
  setRGBpoint(pixelnumber, redValue, greenValue, blueValue);
  pixel.setPixelColor(pixelnumber, redValue, greenValue, blueValue);
  //pixel.show();
}

// sine wave rainbow
void sineLED(int pixelnumber, int angle)
{
  setRGBpoint(pixelnumber, lights[(angle + 120) % 360], lights[angle],  lights[(angle + 240) % 360]);
  pixel.setPixelColor(pixelnumber, lights[(angle + 120) % 360], lights[angle],  lights[(angle + 240) % 360]);

}

void RainbowMode () {

        if (Mode == 5) {
          //Change the maximum brightness of the LED using potantiometer A2  
          valueA2 = map(analogRead(A2), 0, 1024, 0, 255);   
          randomAmount = random(0, 255); 
          rainbowBright = valueA2 - randomAmount;
          pixel.setBrightness(rainbowBright);
          Serial.println("Mode 5 randomAmount: " + String(randomAmount));
          Serial.println("Mode 5 rainbowBright: " + String(rainbowBright));
        } 
        else;
        
  //Fade in from the beginning of the Rainbow cycle (Red)
  for (int x = 0; x < 255; x++)
  {
    if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment)) {
      x = 0;
      break;
      Serial.println("I Broke");
    }

       if (Mode == 4) {
        //Change the maximum brightness of the LED using potantiometer A2      
        rainbowBright = map(analogRead(A2), 0, 1024, 0, 100);
        pixel.setBrightness(rainbowBright);
        //Serial.println("Mode 4 rainbowBright: " + String(rainbowBright));
      }  
      else;  

    plotCycle();
      
    //Change the rate of the rainbow cycling using potantiometer A0
    //Increase the value of the R value causing a fade in;
    pixel.setPixelColor(pixelnumber, x, 0, 0);

    //A delay amount between each increase in value mapped to A0 and divided
    delayA0(fadeSpeed / 40);
    pixel.show();
  }

  //Run the Rainbow cycle (Red)
  for (int k = 0; k < 360; k++)
  {

    // uncomment the mode (or modes) you need below.

    //trueHSV(0, k);

    powerHSV(0, k);

    //sineLED(0, k);

    pixel.show();

    if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment)) {
      k = 0;
      break;
      Serial.println("I Broke");
    }
    
    //Change the rate of the rainbow cycling using potantiometer A0
    //valueA0 = map(analogRead(A0), 0, 1024, 10, 0-1);
    //valueA0 = map(analogRead(A0), 0, 1024, 0, 20);
    
    
    delayA0(fadeSpeed);


     if (Mode == 4) {
        //Change the maximum brightness of the LED using potantiometer A2      
        rainbowBright = map(analogRead(A2), 0, 1024, 0, 100);
        pixel.setBrightness(rainbowBright);
        //Serial.println("Mode 4 rainbowBright: " + String(rainbowBright));
      }
      else;

    plotCycle();

  }


  //Fade out from the end of the Rainbow (lol) cycle (Red)
  for (int x = 255; x >= 0; x--)
  {
      if ((analogRead(A0) <= ValueZeroAdjustment) && (analogRead(A1) <= ValueZeroAdjustment) && (analogRead(A2) <= ValueZeroAdjustment)) {
        x = 0;
        break;
        Serial.println("I Broke");
      }

     if (Mode == 4) {
        //Change the maximum brightness of the LED using potantiometer A2      
        rainbowBright = map(analogRead(A2), 0, 1024, 0, 100);
        pixel.setBrightness(rainbowBright);
        //Serial.println("Mode 4 rainbowBright: " + String(rainbowBright));
      }
      else;
    
    //Change the rate of the rainbow cycling using potantiometer A0
    //Reduces the value of the R value causing a fade out;
    pixel.setPixelColor(pixelnumber, x, 0, 0);

    //A delay amount between each reduction in value mapped to A0 and divided
    delayA0(fadeSpeed / 40);
    pixel.show();

    plotCycle();
  }

  //Add a delay (ms) at the end of the rainbow cycle using potantiometer A2 while the LED is dark
  //valueA1 = map(analogRead(A1), 0, 1024, 0, 30);
  delayA1(darkDelay);

  plotCycle();
  
  //Serial.println("Rate of Rainbow cycling: " + String(valueA0)  + " ||| Delay between Rainbow cycles (ms): " + String(valueA1) + " ||| Maximum Brightness value: " + String(valueA2));

}


/**

  Write Startup Mode to Memory 

*/
//
//  This Section is waiting for all potentiometers to be fully clockwise for a duration defined as "ValueHighlightTime" 
//  and then will start flashing a pattern of light in preparation for wiritng the startup mode to the Flash/ EEPROM Memory
//


void controlsMax()
{

  // If all the potentiometer are fully clockwise, set "ValueHighReached" to "Ture" and get ready to blink. 
  //
  if ((analogRead(A0) > 1022) && (analogRead(A1) > 1022) && (analogRead(A2) > 1022) && (!ValueHighReached))
  {
    ValueHighTime = millis();  
    ValueHighlightTime = millis(); 
    ValueHighReached = true; 
    Serial.println("Ready to Blink Number One");
    
  }

  //
  // When any potentiometer becomes less than fully Clockwise, write the startup mode to the Flash/ EEPROM Memory
  // then set the pixel color to the right color depending on the Mode
  //
  if (((analogRead(A0) < 1023) or (analogRead(A1) < 1023) or (analogRead(A2) < 1023)) && (ValueHighReached))
  {
    ValueHighTime = 0;   
    ValueHighReached = false; 

    // Write the startupMode to EEPROM Flash Memory
    writeStartupMode();

                        
    pixel.setPixelColor(0, Sketch2Red); 
    pixel.show();
    delay(500);    
    
    if (Mode == 1)
    {
      pixel.setPixelColor(0, Sketch2Pink); 
    }
    if (Mode == 2)
    {
      pixel.setPixelColor(0, 36, 0, 255);
    }
    if (Mode == 3)
    {
      pixel.setPixelColor(0, Sketch2Green); 
    }
    if (Mode == 4)
    {
      pixel.setPixelColor(0, Sketch2Red); 
    }
    if (Mode == 5)
    {
      pixel.setPixelColor(0, Sketch2Red); 
    }
    if (Mode == 6)
    {
      pixel.setPixelColor(0, Sketch2Red); 
    }
    else;
    
    pixel.show();
    Serial.println("Startup Mode written to Flash Memory");
  }

  //If "ValueHighReached" = True and the duration in milleseconds defined for "WaitTime" has been reached, start blinking a pattern and get ready to save the startup mode.
  if (((ValueHighTime + WaitTime) < millis()) && (ValueHighReached))
  {

                      //If all the potentiometer are fully clockwise and a variable duration of time has elapsed, start blinking.
                      if ((ValueHighlightTime + 300) < millis())
                      {

                        
                      //If this is equal to the current mode, alternate the color of the pixel.
                      /*if (Mode == 1)
                                        {
                      //Set the color and turn the led ON.
                      if (ValueHighlight == 0)
                      {
                      ValueHighlightTime = millis();
                      ValueHighlight = 1;
                      pixel.setPixelColor(0, Sketch2Green); 
                      pixel.show();
                      Serial.println("I Think I'm Blink Green");
                      }
                      else
                      //Set the color and turn the led OFF.
                      {
                      ValueHighlightTime = millis();
                      ValueHighlight = 0;
                      pixel.setPixelColor(0, 0x000000); 
                      pixel.show();
                      Serial.println("I Done");
                      } 
                      //If the mode is undefined, alternate the color of the pixel.            
                      else
                      {*/
                        if (ValueHighlight == 0)
                        {
                        ValueHighlightTime = millis();
                        ValueHighlight = 1;
                        pixel.setBrightness(155);
                        //pixel.setPixelColor(0, 255,64,98); 
                        pixel.setPixelColor(0, Sketch2Yellow); 
                        pixel.show();
                        delay(100);
                        pixel.setPixelColor(0, Sketch2Orange); 
                        pixel.show();
                        delay(100);
                        pixel.setPixelColor(0, 20,30,50); 
                        pixel.show();
                        delay(100);
                        Serial.println("Blinking and Saving");
                        }
                        else
                        {
                        ValueHighlightTime = millis();
                        ValueHighlight = 0;
                        Serial.println("I'm ready to write the startup mode");
                        }                                                 
                      //}

                      
                                        
            }
                    
 
  
  }

  
}

void plotCycle()
{
    

    // If the Mode is 5 or less, run print for fades
    if (5 >= Mode)
    {
          Serial.println("Min:0,Max:255");
          LEDBrightness = pixel.getBrightness();
          Serial.println(LEDBrightness); 
          //LEDBrightness = redValue + blueValue + greenValue;
    }

    // If the Mode is 5 or more, run pirnt for strange attractor
    else;
    
    /*
     * 
     if (5 <= Mode)
    {
          //Print some things
          //printStrangeScaled();
          //printStrangeEffective();
          printStrangeXYZ();
    }
   */
}


// STRANGE ATTRACTOR


void strangeAttractor()
{

  controlsMax();
  
  //Don't execute the code if not enough time has elapsed
  if(millis() > nextLorenzUpdate){
    
    lorenzFunction();
    nextLorenzUpdate = millis() + (printDelay);

    brightenColors();

    //A0 potentiometer controls for fade speed
    delayAmount = map(analogRead(A0), 0, 1024, 300, 0);
    //Serial.println(" A2:  " + String(analogRead(A2)) + " a:  " + String(a));

    //A1 potentiometer controls for amount of randomless from less to more random
    b = map(analogRead(A1), 0, 1024, 20, 35);

    //A2 potentiometer controls for maximum brightness
    maxBrightness = map(analogRead(A2), 0, 1024, 0, 255);
    pixel.setBrightness(maxBrightness);


    //Modes
    /* Set a value for each potentiometer (pin) for colors R,G,B. */

    if (Mode == 6)
    {
      pixel.setPixelColor(0, scaledX, 0, 0); //Single Output Scaled X
    }
    if (Mode == 7)
    {
      pixel.setPixelColor(0, scaledX, 0, scaledZ); //Double Output Scaled X & Z
    }
    if (Mode == 8)
    {
      pixel.setPixelColor(0, scaledX, scaledY, scaledZ); //Triple Output Scaled XYZ
    }
    if (Mode == 9)
    {
      pixel.setPixelColor(0, scaledX+scaledY+scaledZ, 0, 0); //Combined Output
    }
    if (Mode == 10)
    {
      //pixel.setPixelColor(0, scaledX, scaledY, scaledZ); //Triple Output Scaled XYZ
      pixel.setPixelColor(0, effectiveR, effectiveG, effectiveB); //Triple Output Less Stable
    }
    

    


    pixel.show();        
    delay(delayAmount);

    //plotCycle();

    //Print some things
    //printStrangeScaled();
    //printStrangeEffective();
    printStrangeXYZ();
    
  }

}

void printStrangeXYZ()
{
  Serial.println("x:  " + String(x) + " y:  " + String(y) + " z:  " + String(z));
  Serial.print("\n"); //Comment this line to not have a space between cicles
  //Serial.println("A0:  " + String(analogRead(A0)) + " A1:  " + String(analogRead(A1)) + " A2:  " + String(analogRead(A2)));
}


void printStrangeScaled()
{
    Serial.print(F("x:  "));
    Serial.println(String(scaledX));
    Serial.print(F("y:  "));
    Serial.println(String(scaledY));
    Serial.print(F("z:  "));
    Serial.println(String(scaledZ));
    Serial.print("\n"); //Comment this line to not have a space between cicles
}

void printStrangeEffective()
{
    Serial.print(F("  |  "));
    Serial.println(effectiveR);
    Serial.print(F("  |  "));
    Serial.println(effectiveG);
    Serial.print(F("  |  "));
    Serial.println(effectiveB);
    Serial.print("\n"); //Comment this line to not have a space between cicles
}

void updateScaling(byte rowA, byte cellA, byte rowB, byte cellB, float checkValue) {

  if(checkValue < scalings[rowA][cellA]){ //If the variable is higher than the current max scale value, then update the max scale value
    scalings[rowA][cellA] = checkValue;
  }

  if(checkValue > scalings[rowB][cellB]){ //If the variable is lower than the current min scale value, then update the min scale value
    scalings[rowB][cellB] = checkValue;
  }
  
}

void lorenzFunction() {

  /*
   * This function performs the calculations for the Lorenz equation
   * 
   * I removed the for cicle and I perform a single calculation to extend the code working time
   * 
   * I divided each equation in two steps:
   * Before I calculation and sum to the old value in the same step, now I divided it
   * 
   */

  dx = (a * (y - x)) * dt;
  dy = (x * (b - z) - y) * dt;
  dz = ((x * y) - (c * z)) * dt;

  x += dx;
  y += dy;
  z += dz;

  /*
   * I don't know exactly what range of values can the lorenz return
   * 
   * So I created a function to adjust the scalings if a value is outside the range
   * 
   */
  
  updateScaling(0,0,1,0,x);
  updateScaling(0,1,1,1,y);
  updateScaling(0,2,1,2,z);

  //Values are scaled to 0-255 to adapt to the analogWrite function

  scaledX = map(x, scalings[0][0], scalings[1][0], 0, 255);
  scaledY = map(y, scalings[0][1], scalings[1][1], 0, 255);
  scaledZ = map(z, scalings[0][2], scalings[1][2], 0, 255);
  
}

#ifdef __arm__
  // should use uinstd.h to define sbrk but Due causes a conflict
  extern "C" char* sbrk(int incr);
#else  // __ARM__
  extern char *__brkval;
#endif  // __arm__
 
int freeMemory() {
    char top;
  #ifdef __arm__
    return &top - reinterpret_cast<char*>(sbrk(0));
  #elif defined(CORE_TEENSY) || (ARDUINO > 103 && ARDUINO != 151)
    return &top - __brkval;
  #else  // __arm__
    return __brkval ? &top - __brkval : &top - __malloc_heap_start;
  #endif  // __arm__
}

void brightenColors() {

  /*
   * Brightness is managed as follows:
   *    When brightness should be maximum:
   *      Nothing appens to not affect the colors
   *     
   *    When brightness should be minimum:
   *      Variables are decreased to obtain minimum brightness without affecting the color
   */

  if(fadeAmount < 0) {
    //Brightness is decreasing
    //Results are decreased to match with the wanted brightness

    effectiveR = brightness;                        //Red (x) is the master
    effectiveG = (scaledX / scaledY) * effectiveR;  //Proportion must remain unchanged
    effectiveB = (scaledX / scaledZ) * effectiveR;  //Proportion must remain unchanged
    
    if (effectiveR < 0) effectiveR = 0; //Results must be greater or equal to 0
    if (effectiveG < 0) effectiveG = 0; //Results must be greater or equal to 0
    if (effectiveB < 0) effectiveB = 0; //Results must be greater or equal to 0
    
    /*Serial.print("Fading  ");
    Serial.print(brightness);
    Serial.print("  ");
    Serial.print(effectiveR);
    Serial.print("  ");
    Serial.print(effectiveG);
    Serial.print("  ");
    Serial.println(effectiveB);
    delay(3000);*/
    
  } else {
    //Brightness is increasing
    //Results remains unchanged

    effectiveR = scaledX;
    effectiveG = scaledY;
    effectiveB = scaledZ;
    
  }
  
  brightness += fadeAmount;

  if (brightness <= 0 || brightness >= 255) {
    fadeAmount = -fadeAmount;
  }
  
}

void writeStartupMode()
{
    startupMode = Mode;
    Serial.println("Setting Mode as startupMode: Mode = " + String(Mode)+ " | startupMode = "+ String(startupMode));
    
    
    // Save into emulated-EEPROM the number increased by 1 for the next run of the sketch
    EEPROM.put(address, (int) (startupMode));
    Serial.println("Writing startupMode - "+ String(startupMode));
  
    if (!EEPROM.getCommitASAP())
    {
      Serial.println("CommitASAP not set. Need commit()");
      EEPROM.commit();
    }
    Serial.println("Done writing to emulated EEPROM.");
}

void readStartupMode()
{

  // Read the content of emulated-EEPROM
  EEPROM.get(address, startupMode);
}
